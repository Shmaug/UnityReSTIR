//#ifndef RESERVOIR_H
#if 0
#define RESERVOIR_H

#include "Lights.cginc"
#include "Sampling.cginc"
#include "Random.cginc"

RWTexture2D<float4> _Image;
RWTexture2D<float4> _Albedo;
RWTexture2D<float4> _DepthNormal;
uint2 _OutputExtent;

uint _Seed;

float4x4 _CameraToWorld;
float4x4 _WorldToCamera;
float4x4 _CameraInverseProjection;

uint _GICandidateSamples;
uint _GIReuseSamples;
float _GIReuseRadius;

struct Path {

};
Path ShiftTo(PackedPathReservoir from, float4 to, out float jacobian) {
    jacobian = 0;
}

// Spatial reuse pattern
struct SampleLocations {
    RandomSampler mSeed;
    int2 mCenter;

    int2 Get(uint index) {
        RandomSampler tmp = mSeed;
        tmp.SkipNext(index);
        return mCenter + int2(SampleConcentricDisc(tmp.NextFloat().xy) * _GIReuseRadius);
    }
};
SampleLocations MakeSampleLocations(inout RandomSampler rng, int2 center) {
    SampleLocations sg;
    sg.mSeed = rng;
    sg.mCenter = center;
    rng.SkipNext(_GIReuseSamples);
    return sg;
}

// Computes the sum of M values from domains which could have generated selectedSample
// this is called Z in the unbiased reuse algorithm from ReSTIR DI.
// Only used in Constant MIS modes
float ComputeMSum(const SampleLocations sg, Path sample) {
    // We know the canonical domain could have generated selectedSample since this function wouldn't have been called otherwise
    float msum = _GICandidateSamples;
    for (uint i = 0; i < _GIReuseSamples; i++) {
        uint2 p = sg.Get(i);
        PackedPathReservoir candidate;
        if (!LoadReservoir(p, candidate))
            continue;

        // Trace our path from p's vertex
        float jacobian;
        const Path pi = ShiftTo(sample, candidate, jacobian);
        if (any(pi.mContribution > 0) && jacobian > 0)
            msum += candidate.value.M;
    }
    return msum;
}

float ComputeMisWeight(SampleLocations sg, Path sample, float jacobian, int sampleSourceDomainIndex) {
    // Generalized Talbot MIS

    float msum = 0;
    float m = 0;
    {
        // sample is already in the canonical domain
        const float mi = _GICandidateSamples * luminance(sample.mContribution) * jacobian;
        msum += mi;
        if (sampleSourceDomainIndex == -1)
            m = mi;
    }
    for (uint i = 0; i < _GIReuseSamples; i++) {
        uint2 p = sg.Get(i);
        PackedPathReservoir candidate;
        if (!LoadReservoir(p, candidate))
            continue;

        // Trace our path from p's vertex
        float jacobian_i;
        const Path pi = ShiftTo(sample, candidate, jacobian_i);
        if (all(pi.mContribution <= 0) || jacobian_i <= 0)
            continue;

        const float mi = candidate.M * luminance(pi.mContribution) * jacobian_i;
        msum += mi;
        if (sampleSourceDomainIndex == i)
            m = mi;
    }
    return safe_divide(m, msum);
}

[shader("raygeneration")]
void SpatialPathReuse() {
    uint2 id = DispatchRaysIndex().xy;
    if (any(id >= _OutputExtent)) return;

    int2 prevPixel = id;
    
    SampleLocations sg = MakeSampleLocations(rng, prevPixel);

    // apply mis weight to current sample
    r.PrepareMerge(ComputeMisWeight(sg, r.p, 1, -1));

    int selected_i = -1;

    for (uint i = 0; i < _GIReuseSamples; i++) {
        PackedPathReservoir candidate;
        if (!LoadReservoir(sg.Get(i), candidate))
            continue;

        if (candidate.W <= 0) {
            r.M += candidate.M;
            continue;
        }

        PathReservoir ri;
        ri.M = candidate.M;
        ri.W = candidate.W;
        float jacobian;
        ri.p = ShiftTo(candidate, vertex, jacobian);
        if (jacobian <= 0) {
            // shift failed. increment M manually since Merge() wont be called.
            r.M += ri.M;
            continue;
        }

        if (r.Merge(rng, ri, ComputeMisWeight(sg, ri.p, jacobian, i), jacobian)) {
            selected_i = int(i);
        }
    }

    if (r.W > 0) {
        // finalize MIS weight if needed
        if      (gMisType == MisType::eConstantBiased)
            r.W = safe_divide(r.W, r.M);
        else if (gMisType == MisType::eConstantFast)
            r.W = safe_divide(r.W, ComputeMSum(sg, r.p.mSuffix));

        r.FinalizeMerge();
    }
}

#endif