#pragma max_recursion_depth 1

#include "Lights.cginc"
#include "Sampling.cginc"
#include "Random.cginc"

RWTexture2D<float4> _Radiance;
RWTexture2D<float4> _Albedo;
RWTexture2D<float4> _Positions;
uint2 _OutputExtent;

uint _Seed;

float4x4 _CameraToWorld;
float4x4 _WorldToCamera;
float4x4 _CameraInverseProjection;

struct PathState {
    float3 _Origin;
    float _DirPdfW;
    float3 _Direction;
    uint _RngState;
    float3 _Throughput;
    uint pad;
};
RWStructuredBuffer<PathState> _State;

uint4 Rand(uint2 id, inout PathState state) {
    RandomSampler s = MakeRandomSampler(_Seed, id, state._RngState);
    uint4 r = s.Next();
    state._RngState = s.mState.w;
    return r;
}
float4 Randf(uint2 id, inout PathState state) {
    RandomSampler s = MakeRandomSampler(_Seed, id, state._RngState);
    float4 r = s.NextFloat();
    state._RngState = s.mState.w;
    return r;
}

void Shade(uint2 id, inout PathState state, ShadingData sd, RayDesc ray) {
    _Radiance[id] += float4(state._Throughput * sd.Emission(), 0);

    if (!all(isfinite(sd._Position))) {
        // background
        state._Throughput = 0;
        return;
    }

    LightSampleRecord lr = SampleLight(sd, -ray.Direction, Rand(id, state));
    float3 radiance = lr._Radiance * lr._Brdf * lr._G / lr._PdfA;
    _Radiance[id] += float4(state._Throughput * radiance, 0);

    state._Direction = SampleCosHemisphere(Randf(id, state).xy);
    state._DirPdfW   = CosHemispherePdfW(state._Direction.z);
    state._Direction = sd.ToWorld(state._Direction);
    state._Throughput *= sd.Brdf(-ray.Direction, state._Direction) / state._DirPdfW;
    state._Origin = OffsetRayOrigin(sd._Position, sd.GeometryNormal(), state._Direction);
}

void GetCameraRay(uint2 id, out float3 origin, out float3 direction) {
    origin    = mul(_CameraToWorld, float4(0, 0, 0, 1)).xyz;
    direction = mul(_CameraInverseProjection, float4((float2(id + 0.5) / float2(_OutputExtent))*2-1, 0, 1)).xyz;
    direction = normalize(mul(_CameraToWorld, float4(direction, 0)).xyz);
}

[shader("raygeneration")]
void TraceFirstBounce() {
    uint2 id = DispatchRaysIndex().xy;
    if (any(id >= _OutputExtent)) return;
    
    _Radiance[id] = float4(0, 0, 0, 1);
    
    PathState state = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    state._Throughput = 1;
    GetCameraRay(id, state._Origin, state._Direction);

    RayDesc ray = MakeRay(state._Origin, state._Direction);
    
    ShadingData sd = TraceRay(ray);

    if (!all(isfinite(sd._Position)))
        _Albedo[id] = 1;
    else
        _Albedo[id] = float4(sd.BaseColor(), 1);
    _Positions[id] = float4(sd._Position, asfloat(sd._PackedGeometryNormal));

    Shade(id, state, sd, ray);

    _State[id.y*_OutputExtent.x + id.x] = state;
}

[shader("raygeneration")]
void TraceNextBounce() {
    uint2 id = DispatchRaysIndex().xy;
    if (any(id >= _OutputExtent)) return;

    PathState state = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    state = _State[id.y*_OutputExtent.x + id.x];
    if (!any(state._Throughput > 0))
        return;
    
    RayDesc ray = MakeRay(state._Origin, state._Direction);
    Shade(id, state, TraceRay(ray), ray);
    
    _State[id.y*_OutputExtent.x + id.x] = state;
}

[shader("miss")]
void Miss(inout ShadingData sd : SV_RayPayload) {
	sd._Position = POS_INFINITY;
    sd.BaseColor(0);
    sd.Emission(0);
}
