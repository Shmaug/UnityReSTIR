#pragma max_recursion_depth 1

#define SAMPLE_LIGHTS
//#define TALBOT_RMIS
//#define RECONNECTION

#include "PathGeneration.cginc"

RWStructuredBuffer<PathReservoir> _PathReservoirsIn;
RWStructuredBuffer<PathReservoir> _PathReservoirsOut;

uint _Seed;
uint _SpatialReuseIteration;
uint _SpatialReuseSamples;
float _SpatialReuseRadius;
float _MCap;

[shader("miss")]
void Miss(inout ShadingData sd : SV_RayPayload) {
	sd._Position = POS_INFINITY;
    sd.BaseColor(1);
    sd.Emission(0);
    sd._PackedGeometryNormal = 0;
}

[shader("raygeneration")]
void TracePaths() {
    uint2 id = DispatchRaysIndex().xy;
    if (any(id >= _OutputExtent)) return;
    
    RayDesc ray = GetCameraRay(id);
    ShadingData sd = TraceRay(ray);

    _Albedo[id]    = float4(sd.BaseColor(), 1);
    _Positions[id] = float4(sd._Position, asfloat(sd._PackedGeometryNormal));

    PathReservoir r = MakeReservoir();

    if (all(isfinite(sd._Position.xyz))) {
        RandomSampler rng = MakeRandomSampler(_Seed, id, 0);
        r = SampleRadiance(sd, ray.Direction, rng);
    }

    _PathReservoirsOut[id.y*_OutputExtent.x + id.x] = r;
    _Radiance[id] = float4(sd.Emission() + r._Sample._Radiance * r._W, 1);
}

float _ReuseX;
bool InScreen(uint2 p) { return all(p < _OutputExtent) && (_ReuseX == 0 || p.x/(float)_OutputExtent.x*sign(_ReuseX) > _ReuseX); }

RWStructuredBuffer<PathReservoir> _PrevReservoirs;
RWTexture2D<float4> _PrevPositions;
float4x4 _PrevWorldToClip;

[shader("raygeneration")]
void TemporalReuse() {
    uint2 id = DispatchRaysIndex().xy;
    if (any(id >= _OutputExtent)) return;

    if (!InScreen(id)) return;
    
    float4 vertex = _Positions[id];
    if (!all(isfinite(vertex.xyz)))
        return;
        
    float4 prevClipPos = mul(_PrevWorldToClip, float4(vertex.xyz, 1));
    uint2 prevPixel = ((prevClipPos.xy/prevClipPos.w)*.5 + .5) * _OutputExtent;
    if (!InScreen(prevPixel))
        return;

    float4 prevVertex = _PrevPositions[prevPixel];
    if (!all(isfinite(prevVertex.xyz)))
        return;
        
    PathReservoir r =_PathReservoirsIn[id.y*_OutputExtent.x + id.x];

    float3 emission = _Radiance[id].rgb - (r._Sample._Radiance * r._W);

    RandomSampler rng = MakeRandomSampler(_Seed, id, 1000);

    {
        PathReservoir candidate = _PrevReservoirs[prevPixel.y*_OutputExtent.x + prevPixel.x];
        if (!(candidate._M > 0))
            return;
        if (candidate._W > 0) {
            float candidateM = candidate._M * Luminance(candidate._Sample._Radiance);
            
            float jacobianToHere;
            candidate._Sample = ShiftTo(candidate._Sample, vertex, jacobianToHere);

            float jacobianToThere;
            PathSample s = ShiftTo(r._Sample, prevVertex, jacobianToThere);
            /*
            if (jacobianToHere > 0) {
                candidateM /= jacobianToHere;
                candidateM /= candidateM + Luminance(candidate._Sample._Radiance)*r._M;
                candidate.PrepareMerge(candidateM, jacobianToHere);
            } else
                candidate._W = 0;

            float myM = r._M * Luminance(r._Sample._Radiance);
            myM /= myM + candidate._M*Luminance(s._Radiance)*jacobianToThere;
            r.PrepareMerge(myM);
            /*/
            r.PrepareMerge(jacobianToThere > 0 ? r._M / (r._M + candidate._M) : 1);
            candidate.PrepareMerge(candidate._M / (r._M + candidate._M), jacobianToHere);
            //*/

            r.Merge(rng.NextFloat().x, candidate);

            r.FinalizeMerge();
        } else
            r._M += candidate._M;
    }

    r._M = min(r._M, _MCap);
    _PathReservoirsOut[id.y*_OutputExtent.x + id.x] = r;

    _Radiance[id] = float4(emission + r._Sample._Radiance * r._W, 1);
}


struct SpatialSampleLocations {
    RandomSampler _RngSeed;
    int2 _Center;

    int2 Get(uint index) {
        RandomSampler tmp = _RngSeed;;
        tmp.SkipNext(index);
        return _Center + int2(SampleConcentricDisc(tmp.NextFloat().xy) * _SpatialReuseRadius);
    }
};
SpatialSampleLocations MakeSpatialSampleLocations(inout RandomSampler rng, int2 center) {
    SpatialSampleLocations sg;
    sg._RngSeed = rng;
    sg._Center = center;
    rng.SkipNext(_SpatialReuseSamples);
    return sg;
}

#ifdef TALBOT_RMIS
float ComputeSpatialMisWeight(SpatialSampleLocations sg, PathReservoir sample, float jacobianToCenter, float centerM, int candidateIndex) {
    float mi = 0;
    float msum = centerM * Luminance(sample._Sample._Radiance) * jacobianToCenter;
    if (candidateIndex == -1)
        mi = msum;
    for (uint i = 0; i < _SpatialReuseSamples; i++) {
        uint2 p = sg.Get(i);
        if (!InScreen(p))
            continue;
        float4 vp = _Positions[p]
        if (!all(isfinite(vp.xyz)))
            continue;

        PathReservoir candidate = _PathReservoirsIn[p.y*_OutputExtent.x + p.x];
        if (!(candidate._M > 0))
            continue;

        // Determine whether p could have generated sample by shifting sample to p's vertex

        float jacobian;
        PathSample shifted = ShiftTo(sample._Sample, vp, jacobian);
        if (jacobian > 0) {
            float m = candidate._M * Luminance(shifted._Radiance) * jacobian;
            msum += m;
            if (candidateIndex == i)
                mi = m;
        }
    }
    return msum > 0 ? mi/msum : 0;
}
float FinalizeSpatialMisWeight(SpatialSampleLocations sg, PathReservoir sample, float centerM, int selectedIndex) {
    return 1;
}
#else
float ComputeSpatialMisWeight(SpatialSampleLocations sg, PathReservoir sample, float jacobianToCenter, float centerM, int candidateIndex) {
    return sample._M;
}
float FinalizeSpatialMisWeight(SpatialSampleLocations sg, PathReservoir sample, float centerM, int selectedIndex) {
    float msum = centerM;
    for (uint i = 0; i < _SpatialReuseSamples; i++) {
        uint2 p = sg.Get(i);
        if (!InScreen(p))
            continue;
        float4 vp = _Positions[p];
        if (!all(isfinite(vp.xyz)))
            continue;

        PathReservoir candidate = _PathReservoirsIn[p.y*_OutputExtent.x + p.x];
        if (!(candidate._M > 0))
            continue;

        if (i == selectedIndex) {
            msum += candidate._M;
            continue;
        }

        // Determine whether p could have generated sample by shifting sample to p's vertex

        float jacobian;
        PathSample shifted = ShiftTo(sample._Sample, vp, jacobian);
        if (jacobian > 0) {
            msum += candidate._M;
        }
    }
    return msum > 0 ? 1/msum : 0;
}
#endif

[shader("raygeneration")]
void SpatialReuse() {
    uint2 id = DispatchRaysIndex().xy;
    if (any(id >= _OutputExtent)) return;

    if (!InScreen(id)) return;
    
    float4 vertex = _Positions[id];
    if (!all(isfinite(vertex.xyz)))
        return;
    
    PathReservoir r =_PathReservoirsIn[id.y*_OutputExtent.x + id.x];

    float3 emission = _Radiance[id].rgb - (r._Sample._Radiance * r._W);

    RandomSampler rng = MakeRandomSampler(_Seed, id, (2+_SpatialReuseIteration)*1000);
    SpatialSampleLocations sg = MakeSpatialSampleLocations(rng, id);

    int selectedIndex = -1;

    float centerM = r._M;
    r.PrepareMerge(ComputeSpatialMisWeight(sg, r, 1, centerM, -1));

    for (uint i = 0; i < _SpatialReuseSamples; i++) {
        int2 p = sg.Get(i);
        if (!InScreen(p))
            continue;
        if (!all(isfinite(_Positions[p].xyz)))
            continue;

        PathReservoir candidate = _PathReservoirsIn[p.y*_OutputExtent.x + p.x];
        if (candidate._M <= 0)
            continue;

        if (candidate._W <= 0 || isnan(candidate._W)) {
            r._M += candidate._M;
            continue;
        }
        
        // shift candidate's sample to here
        float jacobian;
        candidate._Sample = ShiftTo(candidate._Sample, vertex, jacobian);

        if (jacobian <= 0 || isnan(jacobian)) {
            r._M += candidate._M;
            continue;
        }
        
        candidate.PrepareMerge(ComputeSpatialMisWeight(sg, candidate, jacobian, centerM, i), jacobian);
    
        if (r.Merge(rng.NextFloat().x, candidate))
            selectedIndex = i;
    }
    
    if (r._W > 0) {
        r._W *= FinalizeSpatialMisWeight(sg, r, centerM, selectedIndex);
        r.FinalizeMerge();
    }
    
    r._M = min(r._M, _MCap);
    _PathReservoirsOut[id.y*_OutputExtent.x + id.x] = r;

    _Radiance[id] = float4(emission + r._Sample._Radiance * r._W, 1);
}